{"ast":null,"code":"import _regeneratorRuntime from \"/Users/MMayaguari/Documents/GitHub/EthereumRoullette/dapp/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/Users/MMayaguari/Documents/GitHub/EthereumRoullette/dapp/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _slicedToArray from \"/Users/MMayaguari/Documents/GitHub/EthereumRoullette/dapp/packages/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/MMayaguari/Documents/GitHub/EthereumRoullette/dapp/packages/frontend/src/Login/Login.tsx\",\n    _this = this,\n    _s = $RefreshSig$();\n\nimport './Login.css';\nimport React, { useState } from 'react';\nimport Web3 from 'web3';\nvar web3 = undefined; // Will hold the web3 instance\n\nexport var Login = function Login(_ref) {\n  _s();\n\n  var onLoggedIn = _ref.onLoggedIn;\n\n  var _useState = useState(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      loading = _useState2[0],\n      setLoading = _useState2[1]; // Loading button state\n\n\n  var handleAuthenticate = function handleAuthenticate(_ref2) {\n    var publicAddress = _ref2.publicAddress,\n        signature = _ref2.signature;\n    return fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL, \"/auth\"), {\n      body: JSON.stringify({\n        publicAddress,\n        signature\n      }),\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  };\n\n  var handleSignMessage = /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref3) {\n      var publicAddress, nonce, signature;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              publicAddress = _ref3.publicAddress, nonce = _ref3.nonce;\n              _context.prev = 1;\n              _context.next = 4;\n              return web3.eth.personal.sign(\"I am signing my one-time nonce: \".concat(nonce), publicAddress, '' // MetaMask will ignore the password argument here\n              );\n\n            case 4:\n              signature = _context.sent;\n              return _context.abrupt(\"return\", {\n                publicAddress,\n                signature\n              });\n\n            case 8:\n              _context.prev = 8;\n              _context.t0 = _context[\"catch\"](1);\n              throw new Error('You need to sign the message to be able to log in.');\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[1, 8]]);\n    }));\n\n    return function handleSignMessage(_x) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n\n  var handleSignup = function handleSignup(publicAddress) {\n    return fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL, \"/users\"), {\n      body: JSON.stringify({\n        publicAddress\n      }),\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  };\n\n  var handleClick = /*#__PURE__*/function () {\n    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var coinbase, publicAddress;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (window.ethereum) {\n                _context2.next = 3;\n                break;\n              }\n\n              window.alert('Please install MetaMask first.');\n              return _context2.abrupt(\"return\");\n\n            case 3:\n              if (web3) {\n                _context2.next = 14;\n                break;\n              }\n\n              _context2.prev = 4;\n              _context2.next = 7;\n              return window.ethereum.enable();\n\n            case 7:\n              // We don't know window.web3 version, so we use our own instance of Web3\n              // with the injected provider given by MetaMask\n              web3 = new Web3(window.ethereum);\n              _context2.next = 14;\n              break;\n\n            case 10:\n              _context2.prev = 10;\n              _context2.t0 = _context2[\"catch\"](4);\n              window.alert('You need to allow MetaMask.');\n              return _context2.abrupt(\"return\");\n\n            case 14:\n              _context2.next = 16;\n              return web3.eth.getCoinbase();\n\n            case 16:\n              coinbase = _context2.sent;\n\n              if (coinbase) {\n                _context2.next = 20;\n                break;\n              }\n\n              window.alert('Please activate MetaMask first.');\n              return _context2.abrupt(\"return\");\n\n            case 20:\n              publicAddress = coinbase.toLowerCase();\n              setLoading(true); // Look if user with current publicAddress is already present on backend\n\n              fetch(\"\".concat(process.env.REACT_APP_BACKEND_URL, \"/users?publicAddress=\").concat(publicAddress)).then(function (response) {\n                return response.json();\n              }) // If yes, retrieve it. If no, create it.\n              .then(function (users) {\n                return users.length ? users[0] : handleSignup(publicAddress);\n              }) // Popup MetaMask confirmation modal to sign message\n              .then(handleSignMessage) // Send signature to backend on the /auth route\n              .then(handleAuthenticate) // Pass accessToken back to parent component (to save it in localStorage)\n              .then(onLoggedIn).catch(function (err) {\n                window.alert(err);\n                setLoading(false);\n              });\n\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[4, 10]]);\n    }));\n\n    return function handleClick() {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Please select your login method.\", /*#__PURE__*/_jsxDEV(\"br\", {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 118,\n        columnNumber: 5\n      }, _this), \"For the purpose of this demo, only MetaMask login is implemented.\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 4\n    }, _this), /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"Login-button Login-mm\",\n      onClick: handleClick,\n      children: loading ? 'Loading...' : 'Login with MetaMask'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 4\n    }, _this), /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"Login-button Login-fb\",\n      disabled: true,\n      children: \"Login with Facebook\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 125,\n      columnNumber: 4\n    }, _this), /*#__PURE__*/_jsxDEV(\"button\", {\n      className: \"Login-button Login-email\",\n      disabled: true,\n      children: \"Login with Email\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 4\n    }, _this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 115,\n    columnNumber: 3\n  }, _this);\n};\n\n_s(Login, \"/Rjh5rPqCCqf0XYnTUk9ZNavw3Q=\");\n\n_c = Login;\n\nvar _c;\n\n$RefreshReg$(_c, \"Login\");","map":{"version":3,"sources":["/Users/MMayaguari/Documents/GitHub/EthereumRoullette/dapp/packages/frontend/src/Login/Login.tsx"],"names":["React","useState","Web3","web3","undefined","Login","onLoggedIn","loading","setLoading","handleAuthenticate","publicAddress","signature","fetch","process","env","REACT_APP_BACKEND_URL","body","JSON","stringify","headers","method","then","response","json","handleSignMessage","nonce","eth","personal","sign","Error","handleSignup","handleClick","window","ethereum","alert","enable","getCoinbase","coinbase","toLowerCase","users","length","catch","err"],"mappings":"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","sourcesContent":["import './Login.css';\n\nimport React, { useState } from 'react';\nimport Web3 from 'web3';\n\nimport { Auth } from '../types';\n\ninterface Props {\n\tonLoggedIn: (auth: Auth) => void;\n}\n\nlet web3: Web3 | undefined = undefined; // Will hold the web3 instance\n\nexport const Login = ({ onLoggedIn }: Props): JSX.Element => {\n\tconst [loading, setLoading] = useState(false); // Loading button state\n\n\tconst handleAuthenticate = ({\n\t\tpublicAddress,\n\t\tsignature,\n\t}: {\n\t\tpublicAddress: string;\n\t\tsignature: string;\n\t}) =>\n\t\tfetch(`${process.env.REACT_APP_BACKEND_URL}/auth`, {\n\t\t\tbody: JSON.stringify({ publicAddress, signature }),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tmethod: 'POST',\n\t\t}).then((response) => response.json());\n\n\tconst handleSignMessage = async ({\n\t\tpublicAddress,\n\t\tnonce,\n\t}: {\n\t\tpublicAddress: string;\n\t\tnonce: string;\n\t}) => {\n\t\ttry {\n\t\t\tconst signature = await web3!.eth.personal.sign(\n\t\t\t\t`I am signing my one-time nonce: ${nonce}`,\n\t\t\t\tpublicAddress,\n\t\t\t\t'' // MetaMask will ignore the password argument here\n\t\t\t);\n\n\t\t\treturn { publicAddress, signature };\n\t\t} catch (err) {\n\t\t\tthrow new Error(\n\t\t\t\t'You need to sign the message to be able to log in.'\n\t\t\t);\n\t\t}\n\t};\n\n\tconst handleSignup = (publicAddress: string) =>\n\t\tfetch(`${process.env.REACT_APP_BACKEND_URL}/users`, {\n\t\t\tbody: JSON.stringify({ publicAddress }),\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/json',\n\t\t\t},\n\t\t\tmethod: 'POST',\n\t\t}).then((response) => response.json());\n\n\tconst handleClick = async () => {\n\t\t// Check if MetaMask is installed\n\t\tif (!(window as any).ethereum) {\n\t\t\twindow.alert('Please install MetaMask first.');\n\t\t\treturn;\n\t\t}\n\n\t\tif (!web3) {\n\t\t\ttry {\n\t\t\t\t// Request account access if needed\n\t\t\t\tawait (window as any).ethereum.enable();\n\n\t\t\t\t// We don't know window.web3 version, so we use our own instance of Web3\n\t\t\t\t// with the injected provider given by MetaMask\n\t\t\t\tweb3 = new Web3((window as any).ethereum);\n\t\t\t} catch (error) {\n\t\t\t\twindow.alert('You need to allow MetaMask.');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tconst coinbase = await web3.eth.getCoinbase();\n\t\tif (!coinbase) {\n\t\t\twindow.alert('Please activate MetaMask first.');\n\t\t\treturn;\n\t\t}\n\n\t\tconst publicAddress = coinbase.toLowerCase();\n\t\tsetLoading(true);\n\n\t\t// Look if user with current publicAddress is already present on backend\n\t\tfetch(\n\t\t\t`${process.env.REACT_APP_BACKEND_URL}/users?publicAddress=${publicAddress}`\n\t\t)\n\t\t\t.then((response) => response.json())\n\t\t\t// If yes, retrieve it. If no, create it.\n\t\t\t.then((users) =>\n\t\t\t\tusers.length ? users[0] : handleSignup(publicAddress)\n\t\t\t)\n\t\t\t// Popup MetaMask confirmation modal to sign message\n\t\t\t.then(handleSignMessage)\n\t\t\t// Send signature to backend on the /auth route\n\t\t\t.then(handleAuthenticate)\n\t\t\t// Pass accessToken back to parent component (to save it in localStorage)\n\t\t\t.then(onLoggedIn)\n\t\t\t.catch((err) => {\n\t\t\t\twindow.alert(err);\n\t\t\t\tsetLoading(false);\n\t\t\t});\n\t};\n\n\treturn (\n\t\t<div>\n\t\t\t<p>\n\t\t\t\tPlease select your login method.\n\t\t\t\t<br />\n\t\t\t\tFor the purpose of this demo, only MetaMask login is\n\t\t\t\timplemented.\n\t\t\t</p>\n\t\t\t<button className=\"Login-button Login-mm\" onClick={handleClick}>\n\t\t\t\t{loading ? 'Loading...' : 'Login with MetaMask'}\n\t\t\t</button>\n\t\t\t<button className=\"Login-button Login-fb\" disabled>\n\t\t\t\tLogin with Facebook\n\t\t\t</button>\n\t\t\t<button className=\"Login-button Login-email\" disabled>\n\t\t\t\tLogin with Email\n\t\t\t</button>\n\t\t</div>\n\t);\n};\n"]},"metadata":{},"sourceType":"module"}